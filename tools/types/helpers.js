/*
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const assert = require('assert');
const typedoc = require('typedoc');
const typedocModels = require('typedoc/dist/lib/models');
const htmlEscaper = require('html-escaper');

const {ReflectionKind} = typedocModels;

/**
 * @param {typedoc.DeclarationReflection} reflection
 * @param {typedoc.ReflectionKind=} kindMask
 * @return {{[name: string]: typedoc.DeclarationReflection}}
 */
function exportedChildren(reflection, kindMask = 0) {
  /** @type {{[name: string]: typedoc.DeclarationReflection}} */
  const all = {};

  for (let cand of reflection.children ?? []) {
    if (!cand.flags.hasFlag(typedoc.ReflectionFlag.Exported)) {
      continue;
    }
    const {name} = cand;

    if (cand.kind === typedoc.ReflectionKind.Reference) {
      const reference = /** @type {typedoc.ReferenceReflection} */ (cand);
      const target = reference.getTargetReflection();
      if (!(target instanceof typedocModels.DeclarationReflection)) {
        continue;
      }
      cand = target;
    }

    if (!(cand.kind & kindMask)) {
      continue;
    }
    all[name] = cand;
  }

  return all;
}

/**
 * @param {typedocModels.Comment|string|undefined} comment
 * @param {typedocModels.Reflection} owner
 * @param {boolean} ensureParagraphs
 * @return {string}
 */
function extractComment(comment, owner, ensureParagraphs = true) {
  let raw = '';

  if (!comment) {
    // do nothing
  } else if (typeof comment === 'string') {
    raw = comment;
  } else {
    // TypeDoc generates both a shortText and text field, which are the same parts of the comment.
    // Merge them before we continue. This can often be the cause (below) of
    // "content\n<p>more content</p>".
    raw = comment?.shortText ?? '';
    if (raw && comment?.text) {
      raw += '\n';
      if (!ensureParagraphs) {
        throw new TypeError('must ensureParagraphs if there is long-form text');
      }
    }
    raw += comment?.text ?? '';
  }

  raw = raw.replace(/\{@link\s+([^}\s]+)\s*(.*?)}/gs, (_, id, note) => {
    const resolved = resolveLink(id, owner);

    const generated = generateHtmlLink(owner, resolved);
    if (generated === null) {
      return note ? note : `<code>${id}</code>`;
    }

    const {name, link} = generated;
    const inner = note ? note : `<code>${name}</code>`;
    return `<a href="${link}">${inner}</a>`;
  });

  // This rewrites URLs that look like "foo#bar" or "foo" to be "../foo#bar".
  // This fixes URLs that are found within comments that incorrectly reference adjacent pages, but
  // all reference pages are actually 'up' one directory.
  raw = raw.replace(/href=(["'])(\w+[#\w]*)\1/g, (_, _quote, inner) => {
    const m = /(\w+)(#\w*|)/.exec(inner);
    if (!m) {
      return '';
    }

    const pathname = m[1];
    const suffix = m[2];

    const namespace = getNamespace(owner);
    const resolved = resolveLink(pathname.replace('_', '.'), namespace);
    if (resolved === namespace) {
      // For some reason we linked to ourselves. This happens surprisingly often.
      return `href="${suffix}"`;
    } else if (resolved) {
      // This is a real link to a peer namespace.
      return `href="../${pathname}/${suffix}"`;
    }

    // Since this is not a matching namespace, this escapes "/docs/extensions/reference/foo/", and
    // puts the URL under "/docs/extensions/TARGET/".
    return `href="../../${pathname}/${suffix}"`;
  });

  if (ensureParagraphs) {
    return ensureCommentSafeHTML(raw);
  }
  return raw;
}

/**
 * Wraps the passed comment in HTML. Basically ensures the comment is comprised
 * of top-level tags.
 *
 * @param {string} out
 * @return {string}
 */
function ensureCommentSafeHTML(out) {
  out = out.trim();
  if (!out) {
    return '';
  }

  // No paragraph wrapper, include one and return.
  if (!out.includes('<p>')) {
    return `<p>${out}</p>`;
  }

  // Already wrapped in a paragraph. Return.
  if (out.startsWith('<p>') && out.endsWith('</p>')) {
    return out;
  }

  // This is a comment which looks like, and is regularly generated by TS:
  //
  //    Hello, I am some long-form content!
  //    <p>For some reason there's a trailing paragraph!</p>
  //    <pre>/* often a code block here too */</pre>
  //
  // We put the first part in a paragraph.
  if (/<\/\w+>$/.test(out)) {
    const indexOfParagraph = out.indexOf('<p>');
    const initialPart = out.substr(0, indexOfParagraph);
    const restPart = out.substr(indexOfParagraph);
    return `<p>${initialPart}</p>\n${restPart}`;
  }

  // Works around specific issue.
  if (out.endsWith('<p>')) {
    out = out.substr(0, out.length - 3);
    return ensureCommentSafeHTML(out);
  }

  // Drop all HTML entities from this. This only happens in one case where
  // inline HTML is used to demonstrate an example.
  out = htmlEscaper.escape(out);
  return ensureCommentSafeHTML(out);
}

/**
 * @param {RenderType|undefined} a
 * @param {RenderType|undefined} b
 * @return {boolean}
 */
function deepStrictEqual(a, b) {
  try {
    // @ts-ignore
    assert.deepStrictEqual(a, b);
  } catch (e) {
    return false;
  }
  return true;
}

/**
 * Generates a HTML link from the given Reflection to the target Reflection, in the format expected
 * by the Chrome Developers site. All chrome.foo namespaces are in peer folders, so relative links
 * are required (e.g., from API 'foo' to 'bar', you would link '../bar/').
 *
 * @param {typedocModels.Reflection} from
 * @param {typedocModels.Reflection|undefined} to
 * @return {{link: string, name: string}?}
 */
function generateHtmlLink(from, to) {
  if (to === undefined) {
    return null;
  }

  // We're never linking _from_ a specific type; just modify 'from'.
  from = getNamespace(from);
  const fromName = getFullName(from);

  const toNamespace = getNamespace(to);
  const toNamespaceName = getFullName(toNamespace);

  // This should never happen, but sanity-check that we're both in the chrome. namespace.
  if (
    !fromName.startsWith('chrome.') ||
    !toNamespaceName.startsWith('chrome.')
  ) {
    return null;
  }

  let htmlPrefix = '';
  const shortNamespaceName = toNamespaceName.substr('chrome.'.length);
  if (from !== toNamespace) {
    const segment = shortNamespaceName.replace('.', '_');
    htmlPrefix = `../${segment}/`;
  }

  // This is a direct link to the namespace. Hooray!
  if (to === toNamespace) {
    return {link: htmlPrefix, name: shortNamespaceName};
  }

  // Otherwise, generate an ID based on the type of the thing we're linking to, plus a path.
  // This matches the syntax used on the Chrome Developers site since 2012+.
  let type = 'type';
  if (to.kind === ReflectionKind.Function) {
    type = 'method';
  } else if (to.kind === ReflectionKind.Variable) {
    type = 'property';

    // Events are just properties that have an instanceof chrome.event.Events.
    if (
      to instanceof typedocModels.DeclarationReflection &&
      to.type instanceof typedocModels.ReferenceType &&
      to.type.symbolFullyQualifiedName === 'chrome.events.Event'
    ) {
      type = 'event';
    }
  }

  const toName = getFullName(to);

  // This is the name of the targe type without "chrome.foo" prefixing it.
  const innerShortName = toName.substr(toNamespaceName.length + 1);
  const rest = innerShortName.replace('.', '-');

  const name = htmlPrefix ? toName.substr('chrome.'.length) : innerShortName;
  return {link: `${htmlPrefix}#${type}-${rest}`, name};
}

/**
 * Given an ambiguous "foo.Bar" syntax, resolve the closest type which matches it.
 *
 * @param {string} id
 * @param {typedocModels.Reflection} reflection
 * @return {typedocModels.Reflection|undefined}
 */
function resolveLink(id, reflection) {
  const idParts = id.split('.');

  /** @type {typedocModels.Reflection|undefined} */
  let r = reflection;

  while (r && r.kind !== ReflectionKind.Global) {
    // TODO(samthor): This doesn't deal with _-prefixed things.

    /** @type {typedocModels.Reflection|undefined} */
    let cand = r;
    let i = 0;
    while (i < idParts.length && cand) {
      cand = cand?.getChildByName(idParts[i]);
      ++i;
    }
    if (cand) {
      return cand;
    }

    r = r.parent;
  }

  // Couldn't resolve this one.
  return undefined;
}

/**
 * Find the closest Namespace to the passed reflection.
 *
 * @param {typedocModels.Reflection} reflection
 * @return {typedocModels.Reflection}
 */
function getNamespace(reflection) {
  while (reflection.kind !== ReflectionKind.Module) {
    if (reflection.kind === ReflectionKind.Namespace) {
      return reflection;
    }
    if (!reflection.parent) {
      break;
    }
    reflection = reflection.parent;
  }
  return reflection;
}

/**
 * @param {typedocModels.Reflection|undefined} reflection
 * @return {string}
 */
function getFullName(reflection) {
  const parts = [];
  while (reflection && reflection.kind !== ReflectionKind.Module) {
    parts.unshift(reflection.name);
    reflection = reflection.parent;
  }
  return parts.join('.');
}

/**
 * Find the fully-qualified name for this type. This will include the "chrome." prefix.
 *
 * @param {typedocModels.ReferenceType} referenceType
 * @return {string}
 */
function resolveFullyQualifiedName(referenceType) {
  // Some types arrive like "foo.bar", but with corrent parents. Grab the right part.
  let initialName = referenceType.name;
  initialName = initialName.split('.').pop() ?? referenceType.name;

  const nameParts = [initialName];
  let reflection = referenceType.reflection?.parent;

  if (referenceType.reflection instanceof typedocModels.ParameterReflection) {
    if (referenceType.reflection?.type === referenceType) {
      // TODO(samthor): This happens incorrectly when a function looks like `(Foo: Foo): void`, and
      // the parameter name matches the type.
      // Look up to the nearest Namespace to find the correct type.

      /** @type {typedocModels.Reflection|undefined} */
      let cand = referenceType.reflection;
      while (cand && cand.kind !== ReflectionKind.Namespace) {
        cand = cand.parent;
      }

      // Load our expected type, and then go to its parent again. If it's not valid this will end
      // up as undefined and we'll just show the initial name.
      reflection = cand?.getChildByName(nameParts[0])?.parent;
    }
  }

  while (reflection && reflection.kind !== ReflectionKind.Module) {
    // See if there's a matching parent type of the same name without leading "_". This works
    // around escaped names but assumes we're solving it with a _ prefix.
    if (/_\w/.test(reflection.name)) {
      const checkName = reflection.name.slice(1);
      const check = reflection.parent?.getChildByName(checkName);
      reflection = check ?? reflection;
    }
    nameParts.unshift(reflection.name);
    reflection = reflection.parent;
  }

  return nameParts.join('.');
}

module.exports = {
  exportedChildren,
  extractComment,
  deepStrictEqual,
  resolveFullyQualifiedName,
  generateHtmlLink,
};

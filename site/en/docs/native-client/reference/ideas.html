---json
{"title":"Contributor Ideas"}
---
<html><head></head><body>
{% include 'partials/nacl-warning.njk' %}

<hr><section id="contributor-ideas" class="stack">

<div class="contents local stack-recursive" id="contents" style="display: none">
<ul>
<li><a class="reference internal" href="#contributing-me" id="id9">Contributing? Me&#x203D;</a></li>
<li><a class="reference internal" href="#google-summer-of-code" id="id10">Google Summer of Code</a></li>
<li><p class="first"><a class="reference internal" href="#id2" id="id11">Ideas</a></p>
<ul>
<li><p class="first"><a class="reference internal" href="#ports" id="id12">Ports</a></p>
<ul>
<li><a class="reference internal" href="#new-filesystems" id="id13">New Filesystems</a></li>
<li><a class="reference internal" href="#open-source-porting" id="id14">Open Source Porting</a></li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#languages" id="id15">Languages</a></p>
<ul>
<li><a class="reference internal" href="#rust" id="id16">Rust</a></li>
<li><a class="reference internal" href="#haskell" id="id17">Haskell</a></li>
<li><a class="reference internal" href="#julia" id="id18">Julia</a></li>
<li><a class="reference internal" href="#scala" id="id19">Scala</a></li>
<li><a class="reference internal" href="#elm" id="id20">Elm</a></li>
<li><a class="reference internal" href="#mono" id="id21">Mono</a></li>
<li><a class="reference internal" href="#perl" id="id22">Perl</a></li>
</ul>
</li>
<li><a class="reference internal" href="#tcc" id="id23">TCC</a></li>
<li><p class="first"><a class="reference internal" href="#llvm-and-pnacl" id="id24">LLVM and PNaCl</a></p>
<ul>
<li><a class="reference internal" href="#sandboxing-optimizations" id="id25">Sandboxing Optimizations</a></li>
<li><a class="reference internal" href="#binary-size-reduction" id="id26">Binary Size Reduction</a></li>
<li><a class="reference internal" href="#vector-support" id="id27">Vector Support</a></li>
<li><a class="reference internal" href="#atomics" id="id28">Atomics</a></li>
<li><a class="reference internal" href="#security-enhanced-pnacl" id="id29">Security-enhanced PNaCl</a></li>
<li><a class="reference internal" href="#sanitizer-support" id="id30">Sanitizer Support</a></li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#nacl" id="id31">NaCl</a></p>
<ul>
<li><a class="reference internal" href="#auto-sandboxing" id="id32">Auto-Sandboxing</a></li>
<li><a class="reference internal" href="#new-sandbox" id="id33">New Sandbox</a></li>
<li><a class="reference internal" href="#bit-sandbox" id="id34">64-bit Sandbox</a></li>
</ul>
</li>
</ul>
</li>
</ul>

</div><h2 id="contributing-me">Contributing? Me&#x203D;</h2>
<p>NaCl and PNaCl are very big projects: they expose an entire operating system to
developers, interact with all of the Web platform, and deal with compilers
extensively to allow code written in essentially any programming language to
execute on a variety of CPU architectures. This can be daunting when trying to
figure out how to contribute to the open-source project! This page tries to make
contributing easier by listing project ideas by broad area of interest, and
detailing the required experience and expectations for each idea.</p>
<p>This isn&#x2019;t meant to constrain contributions! If you have ideas that aren&#x2019;t on
this page please contact the <a class="reference external" href="https://groups.google.com/group/native-client-discuss">native-client-discuss</a> mailing list.</p>
<p>If you like an idea on this page and would like to get started, contact the
<a class="reference external" href="https://groups.google.com/group/native-client-discuss">native-client-discuss</a> mailing list so that we can help you find a mentor.</p>
<h2 id="google-summer-of-code">Google Summer of Code</h2>
<p>PNaCl participates in the <a class="reference external" href="https://www.google-melange.com/gsoc/homepage/google/gsoc2015">2015 Google Summer of Code</a> (see the <a class="reference external" href="https://www.google-melange.com/gsoc/org2/google/gsoc2015/pnacl">PNaCl GSoC
page</a>). <a class="reference external" href="https://www.google-melange.com/gsoc/document/show/gsoc_program/google/gsoc2015/help_page#4._How_does_a_student_apply">Student applications</a> are open March 16&#x2013;27. Discuss project ideas no
<a class="reference external" href="https://groups.google.com/group/native-client-discuss">native-client-discuss</a>, and submit your proposal on the GSoC page by the
deadline.</p>
<h2 id="id2">Ideas</h2>
<p>We&#x2019;ve separated contributor ideas into broad areas of interest:</p>
<ul>
<li><strong>Ports</strong> encompass all the code that <em>uses</em> the PNaCl platform. Put simply,
the point of ports is to make existing open-source code work.</li>
<li><strong>Programming languages</strong> sometimes involves compiler work, and sometimes
requires getting an interpreter and its APIs to work well within the Web
platform.</li>
<li><strong>LLVM and PNaCl</strong> requires compiler work: PNaCl is based on the LLVM
toolchain, and most of the work in this area would occur in the upstream LLVM
repository.</li>
<li><strong>NaCl</strong> mostly deals with low-level systems work and security.</li>
</ul>
<h3 id="ports">Ports</h3>
<h4 id="new-filesystems">New Filesystems</h4>
<ul>
<li><strong>Project:</strong> Expose new filesystems to <a class="reference internal" href="/docs/native-client/devguide/coding/nacl_io"><em>nacl_io</em></a>.</li>
<li><strong>Brief explanation:</strong> nacl_io exposes filesystems like html5fs and RAM disk,
which can be mounted and then accessed through regular POSIX APIs. New types
of filesystems could be exposed in a similar way, allowing developers to build
apps that &#x201C;just work&#x201D; on the Web platform while using Web APIs. A few ideas
include connecting to: Google Drive, Github, Dropbox.</li>
<li><strong>Expected results:</strong> A new filesystem is mountable using nacl_io, is well
tested, and used in a demo application.</li>
<li><strong>Knowledge Prerequisite:</strong> C++.</li>
<li><strong>Mentor:</strong> Sam Clegg.</li>
</ul>
<h4 id="open-source-porting">Open Source Porting</h4>
<ul>
<li><strong>Project:</strong> Port substantial open source projects to work in webports.</li>
<li><strong>Brief explanation:</strong> webports contains a large collection of open source
projects that properly compile and run on the PNaCl platform. This project
involves adding new useful projects to webports, and upstreaming any patches
to the original project: running on PNaCl effective involves porting to a new
architecture and operating system. Project ideas include: Gimp, Inkscape, Gtk.</li>
<li><strong>Expected results:</strong> New open source projects are usable from webports.</li>
<li><strong>Knowledge Prerequisite:</strong> C/C++.</li>
<li><strong>Mentor:</strong> Brad Nelson.</li>
</ul>
<h3 id="languages">Languages</h3>
<p>PNaCl already has support for C and C++, and virtual machines such as
JavaScript, Lua, Python and Ruby. We&#x2019;d like to support more languages, either by
having these languages target LLVM bitcode or by making sure that the language
virtual machine&#x2019;s APIs work well on the Web platform.</p>
<h4 id="rust">Rust</h4>
<ul>
<li><strong>Project:</strong> Support the Rust programming languages.</li>
<li><strong>Brief explanation:</strong> The <a class="reference external" href="http://www.rust-lang.org">Rust</a> programming language uses LLVM. The aim of
this project is to allow it to deliver PNaCl <code>.pexe</code> files.</li>
<li><strong>Expected results:</strong> The Rust test suite passes within the browser. How to
use Rust to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, LLVM.</li>
<li><strong>Mentor:</strong> Ben Smith.</li>
</ul>
<h4 id="haskell">Haskell</h4>
<ul>
<li><strong>Project:</strong> Support the Haskell programming language.</li>
<li><strong>Brief explanation:</strong> <a class="reference external" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html">GHC</a> targets LLVM. The aim of this project is to allow
it to deliver PNaCl <code>.pexe</code> files. One interesting difficulty will be to
ensure that tail call optimization occurs properly in all targets.</li>
<li><strong>Expected results:</strong> The Haskell test suite passes within the browser. How to
use Haskell to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, LLVM.</li>
<li><strong>Mentor:</strong> Ben Smith.</li>
</ul>
<h4 id="julia">Julia</h4>
<ul>
<li><strong>Project:</strong> Support the Julia programming language.</li>
<li><strong>Brief explanation:</strong> <a class="reference external" href="http://julialang.org">Julia</a> targets LLVM, but it does so through LLVM&#x2019;s
Just-in-Time compiler which PNaCl doesn&#x2019;t support. The aim of this project is
to allow it to deliver PNaCl <code>.pexe</code> files.</li>
<li><strong>Expected results:</strong> The Julia test suite passes within the browser. How to
use Julia to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, LLVM.</li>
<li><strong>Mentor:</strong> Ben Smith.</li>
</ul>
<h4 id="scala">Scala</h4>
<ul>
<li><strong>Project:</strong> Support the Scala programming language.</li>
<li><strong>Brief explanation:</strong> The aim of this project is to allow <a class="reference external" href="http://www.scala-lang.org">Scala</a> to deliver
PNaCl <code>.pexe</code> files.</li>
<li><strong>Expected results:</strong> The Scala test suite passes within the browser. How to
use Scala to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers.</li>
<li><strong>Mentor:</strong> Ben Smith.</li>
</ul>
<h4 id="elm">Elm</h4>
<ul>
<li><strong>Project:</strong> Support the Elm programming language.</li>
<li><strong>Brief explanation:</strong> The aim of this project is to allow <a class="reference external" href="http://elm-lang.org">Elm</a> to deliver
PNaCl <code>.pexe</code> files.</li>
<li><strong>Expected results:</strong> The Elm test suite passes within the browser. How to use
Elm to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers.</li>
<li><strong>Mentor:</strong> Jan Voung.</li>
</ul>
<h4 id="mono">Mono</h4>
<ul>
<li><strong>Project:</strong> Support C# running inside Mono.</li>
<li><strong>Brief explanation:</strong> C# is traditionally a Just-in-Time compiled language,
the aim of this project is to be able to run C# code within <a class="reference external" href="http://www.mono-project.com">Mono</a> while
compiling ahead-of-time.</li>
<li><strong>Expected results:</strong> The Mono test suite passes within the browser. How to
use Mono to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers.</li>
<li><strong>Mentor:</strong> Derek Schuff.</li>
</ul>
<h4 id="perl">Perl</h4>
<ul>
<li><strong>Project:</strong> Support Perl.</li>
<li><strong>Brief explanation:</strong> Port the Perl programming language and its packages to
the PNaCl platform.</li>
<li><strong>Expected results:</strong> The Perl test suite passes within the browser. How to
use Perl to target PNaCl is well documented and easy to do.</li>
<li><strong>Knowledge Prerequisite:</strong> C.</li>
<li><strong>Mentor:</strong> Brad Nelson.</li>
</ul>
<h3 id="tcc">TCC</h3>
<ul>
<li><strong>Project:</strong> Port Fabrice Ballard&#x2019;s Tiny C Compiler _TCC to NaCl and PNaCl.</li>
<li><strong>Brief explanation:</strong> Port TCC to NaCl and enhance to follow <a class="reference external" href="/native-client/reference/sandbox_internals/index">NaCl sandboxing
rules</a>, as well as emitting <a class="reference external" href="/native-client/reference/pnacl-bitcode-manual">PNaCl bitcode</a>. The same could be done with
<a class="reference external" href="https://code.google.com/p/picoc">Pico C</a>.</li>
<li><strong>Expected results:</strong> Compiler ported and code generator working. Can run a
small benchmark of your choice.</li>
<li><strong>Knowledge Prerequisite:</strong> C, assembly, compilers.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h3 id="llvm-and-pnacl">LLVM and PNaCl</h3>
<p>PNaCl relies heavily on LLVM in two key areas:</p>
<ul>
<li>On the developer&#x2019;s machine, LLVM is used as a regular toolchain to parse code,
optimize it, and create a portable executable.</li>
<li>On user devices, LLVM is installed as part of Chrome to translate a portable
executable into a machine-specific sandboxed executable.</li>
</ul>
<p>Most of the contribution ideas around LLVM would occur in the upstream LLVM
repository, and would improve LLVM for more than just PNaCl&#x2019;s sake (though PNaCl
is of course benefiting from these improvements!). Some of these ideas would
also apply to <a class="reference external" href="https://chromium.googlesource.com/native_client/pnacl-subzero/+/master/README.rst">Subzero</a>, a small and fast translator from portable executable to
machine-specific code.</p>
<h4 id="sandboxing-optimizations">Sandboxing Optimizations</h4>
<ul>
<li><strong>Project:</strong> Improved sandboxed code generation.</li>
<li><strong>Brief explanation:</strong> PNaCl generates code that targets the NaCl sandbox, but
this code generation isn&#x2019;t always optimal and sometimes results in a
performance lost of 10% to 25% compared to unsandboxed code. This project
would require looking at the x86-32, x86-64, ARM and MIPS code being generated
by LLVM or Subzero and figuring out how it can be improved to execute
faster. As an example, one could write a compiler pass to figure out when
doing a zero-extending <code>lea</code> on NaCl x86-64 would be useful (increment and
sandbox), or see if <code>%rbp</code> can be used more for loads/stores unrelated to
the call frame.</li>
<li><strong>Expected results:</strong> Sandboxed code runs measurably faster, and gets much
closer to unsandboxed code performance. PNaCl has a fairly extensive
performance test suite to measure these improvements.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, assembly.</li>
<li><strong>Mentor:</strong> Jan Voung.</li>
</ul>
<h4 id="binary-size-reduction">Binary Size Reduction</h4>
<ul>
<li><strong>Project:</strong> Reduce the size of binaries generated by LLVM.</li>
<li><strong>Brief explanation:</strong> This is generally useful for the LLVM project, but is
especially important for PNaCl and Emscripten because we deliver code on the
Web (transfer size and compile time matter!). This stands to drastically
improve transfer time, and load time. Reduces the size of the PNaCl translator
as well as user code, makes the generated portable executables smaller and
translation size faster. Improve LLVM&#x2019;s <code>mergefuncs</code> pass to reduce
redundancy of code. Detect functions and data that aren&#x2019;t used. Improve
partial evaluation: can e.g. LLVM&#x2019;s command-line parsing be mostly removed
from the PNaCl translator?  Potentially add a pass where a developer manually
marks functions as unused, and have LLVM replace them with <code>abort</code> (this
should propagate and mark other code as dead). This list could be created by
using code coverage information.</li>
<li><strong>Expected results:</strong> Portable executables in the PNaCl repository are
measurably smaller and translate faster.</li>
<li><strong>Knowledge Prerequisite:</strong> LLVM bitcode.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h4 id="vector-support">Vector Support</h4>
<ul>
<li><strong>Project:</strong> Improve PNaCl SIMD support.</li>
<li><strong>Brief explanation:</strong> PNaCl offers speed on the Web, and generating good SIMD
code allows developers to use the full capabilities of the device (better user
experience, longer battery life). The goal of this project is to allow
developers to use more hardware features in a portable manner by exposing
portable SIMD primitives and using auto-vectorization. This could also mean
making the architecture-specific intrinsics &#x201C;just work&#x201D; within PNaCl (lower
them to equivalent architecture-independent intrinsics).</li>
<li><strong>Expected results:</strong> Sample code and existing applications run measurably
faster by using portable SIMD and/or by auto-vectorizing.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, high-performance code tuning.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h4 id="atomics">Atomics</h4>
<ul>
<li><strong>Project:</strong> Improve the performance of C++11 atomics.</li>
<li><strong>Brief explanation:</strong> C++11 atomics allow programmers to shed inline assembly
and use language-level features to express high-performance code. This is
great for portability, but atomics currently aren&#x2019;t as fast as they could be
on all platforms. We had an intern work on this in the summer of 2014, see his
LLVM developer conference presentation <a class="reference external" href="http://llvm.org/devmtg/2014-10/#talk10">Blowing up the atomic barrier</a>. This
project would be a continuation of this work: improve LLVM&#x2019;s code generation
for atomics.</li>
<li><strong>Expected results:</strong> Code using C++11 atomics runs measurably faster on
different architectures.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers, memory models.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h4 id="security-enhanced-pnacl">Security-enhanced PNaCl</h4>
<ul>
<li><strong>Project:</strong> Security in-depth for PNaCl.</li>
<li><strong>Brief explanation:</strong> PNaCl brings native code to the Web, and we want to
improve the security of the platform as well as explore novel mitigations.
This allows PNaCl to take better advantage of the hardware and operating
system it&#x2019;s running on and makes the platform even faster while keeping users
safe. It&#x2019;s also useful for non-browser uses of PNaCl such as running untrusted
code in the Cloud. A few areas to explore are: code randomization for LLVM and
Subzero, fuzzing of the translator, code hiding at compilation time, and code
tuning to the hardware and operating system the untrusted code is running on.</li>
<li><strong>Expected results:</strong> The security design and implementation successfully pass
a review with the Chrome security team.</li>
<li><strong>Knowledge Prerequisite:</strong> Security.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h4 id="sanitizer-support">Sanitizer Support</h4>
<ul>
<li><strong>Project:</strong> Sanitizer support for untrusted code.</li>
<li><strong>Brief explanation:</strong> LLVM supports many <a class="reference external" href="http://clang.llvm.org/docs/UsersManual.html#controlling-code-generation">sanitizers</a> for C/C++ using the
<code>-fsanitize=&lt;name&gt;</code>. Some of these sanitizers currently work, and some don&#x2019;t
because they use clever tricks to perform their work, such as using <code>mmap</code>
to allocate a special shadow memory region with a specific address. This
project requires adding full support to all of LLVM&#x2019;s sanitizers for untrusted
user code within PNaCl.</li>
<li><strong>Expected results:</strong> The sanitizer tests successfully run as untrusted code
within PNaCl.</li>
<li><strong>Knowledge Prerequisite:</strong> Compilers.</li>
<li><strong>Mentor:</strong> JF Bastien.</li>
</ul>
<h3 id="nacl">NaCl</h3>
<h4 id="auto-sandboxing">Auto-Sandboxing</h4>
<ul>
<li><strong>Project:</strong> Auto-sandboxing assembler.</li>
<li><strong>Brief explanation:</strong> NaCl has a toolchain which can sandbox native
code. This toolchain can consume C/C++ as well as pre-sandboxed assembly, or
assembly which uses special sandboxing macros. The goal of this project is to
follow NaCl&#x2019;s sandboxing requirements automatically which compiling assembly
files.</li>
<li><strong>Expected results:</strong> Existing assembly code can be compiled to a native
executable that follows NaCl&#x2019;s sandboxing rules.</li>
<li><strong>Knowledge Prerequisite:</strong> Assemblers.</li>
<li><strong>Mentor:</strong> Derek Schuff, Roland McGrath.</li>
</ul>
<h4 id="new-sandbox">New Sandbox</h4>
<ul>
<li><strong>Project:</strong> Create a new software-fault isolation sandbox.</li>
<li><strong>Brief explanation:</strong> NaCl pioneered production-quality sandboxes based on
software-fault isolation, and currently supports x86-32, x86-64, ARMv7&#x2019;s ARM,
and MIPS. This project involves designing and implementing new sandboxes. Of
particular interest are ARMv8&#x2019;s aarch64 and Power8. This also requires
implementing sandboxing in the compiler.</li>
<li><strong>Expected results:</strong> The new sandbox&#x2019;s design and implementation successfully
pass a review with the Chrome security team. Existing NaCl code successfully
runs in the new sandbox.</li>
<li><strong>Knowledge Prerequisite:</strong> Security, low-level assembly, compilers, LLVM.</li>
<li><strong>Mentor:</strong> David Sehr.</li>
</ul>
<h4 id="bit-sandbox">64-bit Sandbox</h4>
<ul>
<li><strong>Project:</strong> Create a 64-bit sandbox.</li>
<li><strong>Brief explanation:</strong> NaCl currently supports sandboxes where pointers are
32-bits. Some applications, both in-browser and not in-browser, would benefit
from a larger address space. This project involves designing and implementing
a model for 64-bit sandboxes on all architecture NaCl currently supports. This
also requires supporting 64-bit pointers in PNaCl using the <code>le64</code> platform,
and updating the code generation for each platform.</li>
<li><strong>Expected results:</strong> The new sandbox&#x2019;s design and implementation successfully
pass a review with the Chrome security team. Existing NaCl code successfully
runs in the new sandbox.</li>
<li><strong>Knowledge Prerequisite:</strong> Security, low-level assembly, compilers, LLVM.</li>
<li><strong>Mentor:</strong> David Sehr.</li>
</ul>
</section>


</body></html>
---json
{"title":"Technical Overview"}
---
<html><head></head><body>
{% Partial 'nacl-warning.njk' %}

<hr><section id="technical-overview" class="stack">

<div class="contents local stack-recursive" id="contents" style="display: none">
<ul>
<li><a class="reference internal" href="#why-use-native-client" id="id7">Why use Native Client?</a></li>
<li><a class="reference internal" href="#benefits-of-native-client" id="id8">Benefits of Native Client</a></li>
<li><a class="reference internal" href="#common-use-cases" id="id9">Common use cases</a></li>
<li><p class="first"><a class="reference internal" href="#how-native-client-works" id="id10">How Native Client works</a></p>
<ul>
<li><a class="reference internal" href="#toolchains" id="id11">Toolchains</a></li>
<li><a class="reference internal" href="#security" id="id12">Security</a></li>
<li><a class="reference internal" href="#link-for-pnacl-translator" id="id13">Portability</a></li>
</ul>
</li>
<li><p class="first"><a class="reference internal" href="#structure-of-a-web-application" id="id14">Structure of a web application</a></p>
<ul>
<li><a class="reference internal" href="#pepper-plug-in-api" id="id15">Pepper plug-in API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#where-to-start" id="id16">Where to start</a></li>
</ul>

</div><p><strong>Native Client</strong> (NaCl) is an open-source technology for running native
compiled code in the browser, with the goal of maintaining the portability
and safety that users expect from web applications. Native Client expands web
programming beyond JavaScript, enabling you to enhance your web applications
using your preferred language. This document describes some of the key benefits
and common use cases of Native Client.</p>
<p>Google has implemented the open-source <a class="reference external" href="http://www.chromium.org/nativeclient">Native Client project</a> in the Chrome browser on Windows, Mac,
Linux, and ChromeOS. The <a class="reference internal" href="/docs/native-client/sdk/download"><em>Native Client Software Development Kit (SDK)</em></a>, itself an open-source project, lets you create web applications
that use NaCl and run in Chrome across multiple platforms.</p>
<p>A Native Client web application consists of JavaScript, HTML, CSS, and a NaCl
module written in a language supported by the SDK. The NaCl SDK currently
supports C and C++; as compilers for additional languages are developed, the SDK
will be updated.</p>
<div class="figure">
<img alt="A web application with and without Native Client" src="/docs/native-client/images/web-app-with-nacl.png">
<p class="caption">A web application with and without Native Client</p>
</div>
<p>Native Client comes in two flavors: traditional (NaCl) and portable (PNaCl).
Traditional, which must be distributed through the Chrome Web Store lets you
target a specific hardware platform. Portable can run on the open web. A
bitcode file that can be loaded from any web server is downloaded to a client
machine and converted to hardware-specific code before any execution. For
details, see <a class="reference internal" href="/docs/native-client/nacl-and-pnacl"><em>NaCl and PNaCl</em></a>.</p>
<h2 id="why-use-native-client"><span id="id1"></span>Why use Native Client?</h2>
<p>Native Client open-source technology is designed to run compiled code
securely inside a browser at near-native speeds. Native Client gives web
applications some advantages of desktop software. Specifically, it provides the
means to fully harness the client&#x2019;s computational resources for applications
such as:</p>
<ul>
<li>3D games</li>
<li>multimedia editors</li>
<li>CAD modeling</li>
<li>client-side data analytics</li>
<li>interactive simulations.</li>
</ul>
<p>Native Client gives C and C++ (and other languages targeting it) the same level
of portability and safety as JavaScript.</p>
<h2 id="benefits-of-native-client"><span id="id2"></span>Benefits of Native Client</h2>
<p>Benefits of Native Client include:</p>
<ul>
<li><strong>Graphics, audio, and much more:</strong> Running native code modules that render 2D
and 3D graphics, play audio, respond to mouse and keyboard events, run on
multiple threads, and access memory directly&#x2014;all without requiring the user
to install a plug-in.</li>
<li><strong>Portability:</strong> Writing your applications once and running them on multiple
operating systems (Windows, Linux, Mac, and ChromeOS) and CPU architectures
(x86 and ARM).</li>
<li><strong>Easy migration path to the web:</strong> Leveraging years of work in existing
desktop applications. Native Client makes the transition from the desktop to
a web application significantly easier because it supports C and C++.</li>
<li><strong>Security:</strong> Protecting the user&#x2019;s system from malicious or buggy
applications through Native Client&#x2019;s double sandbox model. This model offers
the safety of traditional web applications without sacrificing performance
and without requiring users to install a plug-in.</li>
<li><strong>Performance:</strong> Running at speeds within 5% to 15% of a native desktop
application. Native Client also allows applications to harness all available
CPU cores via a threading API. This enables demanding applications such as
console-quality games to run inside the browser.</li>
</ul>
<h2 id="common-use-cases"><span id="id3"></span>Common use cases</h2>
<p>Typical use cases for Native Client include the following:</p>
<ul>
<li><strong>Existing software components:</strong> Native Client lets you repurpose existing
C and C++ software in web applications. You don&#x2019;t need to rewrite and debug
code that already works. It also lets your application take advantage of
things the browser does well such as handling user interaction and processing
events. You can also take advantage of the latest developments in HTML5.</li>
<li><strong>Legacy desktop applications:</strong> Native Client provides a smooth migration
path from desktop applications to the web. You can port and recompile existing
code for the computation engine of your application directly to Native Client,
and need rebuild only the user interface and event handling portions for the
browser.</li>
<li><strong>Heavy computation in enterprise applications:</strong> Native Client can handle the
number crunching required by large-scale enterprise applications. To ensure
protection of user data, Native Client lets you run complex cryptographic
algorithms directly in the browser so that unencrypted data never goes out
over the network.</li>
<li><strong>Multimedia applications:</strong> Codecs for processing sounds, images, and movies
can be added to the browser in a Native Client module.</li>
<li><strong>Games:</strong> Native Client lets web applications run at close to native
speed, reuse existing multithreaded/multicore C/C++ code bases, and
access low-latency audio, networking APIs, and OpenGL ES with programmable
shaders. Native Client is a natural fit for running a physics engine or
artificial intelligence module that powers a sophisticated web game.
Native Client also enables applications to run unchanged across
many platforms.</li>
<li><strong>Any application that requires acceleration:</strong> Native Client fits seamlessly
into web applications. It&#x2019;s up to you to decide to what extent to use it.
Use of Native Client covers the full spectrum from complete applications to
small optimized routines that accelerate vital parts of web applications.</li>
</ul>
<h2 id="how-native-client-works"><span id="link-how-nacl-works"></span>How Native Client works</h2>
<p>Native Client is an umbrella name for a set of related software components for
developing C/C++ applications and running them securely on the web. At a high
level, Native Client consists of:</p>
<ul>
<li><strong>Toolchains:</strong> collections of development tools (compilers, linkers, etc.)
that transform C/C++ code to Portable Native Client modules or Native Client
modules.</li>
<li><strong>Runtime components:</strong> components embedded in the browser or other host
platforms that allow execution of Native Client modules securely and
efficiently.</li>
</ul>
<p>The following diagram shows how these components interact:</p>
<div class="figure">
<img alt="The Native Client toolchains and their outputs" src="/docs/native-client/images/nacl-pnacl-component-diagram.png">
<p class="caption">The Native Client toolchains and their outputs</p>
</div>
<h3 id="toolchains"><span id="id4"></span>Toolchains</h3>
<p>A Native Client toolchain consists of a compiler, a linker, an assembler and
other tools that are used to convert C/C++ source code into a module that is
loadable by a browser.</p>
<p>The Native Client SDK provides two toolchains:</p>
<ul>
<li>The left side of the diagram shows <strong>Portable Native Client</strong> (PNaCl,
pronounced &#x201C;pinnacle&#x201D;). An LLVM based toolchain produces a single, portable
(<strong>pexe</strong>) module. At runtime an ahead-of-time (AOT) translator, built into
the browser, translates the pexe into native code for the relevant client
architecture.</li>
<li>The right side of the diagram shows <strong>(non-portable) Native Client</strong>. A GCC
based toolchain produces multiple architecture-dependent (<strong>nexe</strong>) modules,
which are packaged into an application. At runtime the browser determines
which nexe to load based on the architecture of the client machine.</li>
</ul>
<p>The PNaCl toolchain is recommended for most applications. The NaCl-GCC
toolchain should only be used for applications that won&#x2019;t be distributed on the
open web.</p>
<h3 id="security"><span id="id5"></span>Security</h3>
<p>Since Native Client permits the execution of native code on client machines,
special security measures have to be implemented:</p>
<ul>
<li>The NaCl sandbox ensures that code accesses system resources only through
safe, whitelisted APIs, and operates within its limits without  attempting to
interfere with other code running either within the browser or outside it.</li>
<li>The NaCl validator statically analyzes code before running it to make sure it
only uses code and data patterns that are permitted and safe.</li>
</ul>
<p>These security measures are in addition to the existing sandbox in the
Chrome browser. The Native Client module always executes in a process with
restricted permissions. The only interaction between this process and the
outside world is through defined browser interfaces. Because of the
combination of the NaCl sandbox and the Chrome sandbox, we say that
Native Client employs a <strong>double sandbox</strong> design.</p>
<h3 id="link-for-pnacl-translator"><span id="portability"></span><span id="id6"></span>Portability</h3>
<p>Portable Native Client (PNaCl, prounounced &#x201C;pinnacle&#x201D;) employs state-of-the-art
compiler technology to compile C/C++ source code to a portable bitcode
executable (<strong>pexe</strong>). PNaCl bitcode is an OS- and architecture-independent
format that can be freely distributed on the web and <a class="reference internal" href="#link-nacl-in-web-apps"><em>embedded in web
applications</em></a>.</p>
<p>The PNaCl translator is a component embedded in the Chrome browser; its task is
to run pexe modules. Internally, the translator compiles a pexe to a nexe
(described above), and then executes the nexe within the Native Client sandbox
as described above. The translator uses intelligent caching to avoid
re-compiling the pexe if it was previously compiled on the client&#x2019;s browser.</p>
<p>Native Client also supports the execution of nexe modules directly in the
browser. However, since nexes contain architecture-specific machine code, they
are not allowed to be distributed on the open web. They can only be used as part
of applications and extensions that are installed from the Chrome Web Store.</p>
<p>For more details on the difference between NaCl and PNaCl, see
<a class="reference internal" href="/docs/native-client/nacl-and-pnacl"><em>NaCl and PNaCl</em></a>.</p>
<h2 id="structure-of-a-web-application"><span id="link-nacl-in-web-apps"></span>Structure of a web application</h2>
<p id="application-files">A Native Client application consists of a set of files:</p>
<ul>
<li><p class="first"><strong>HTML and CSS:</strong> The HTML file tells the browser where to find the manifest
(nmf file) through the embed tag.</p>
<pre class="prettyprint">&lt;embed name=&quot;mygame&quot; src=&quot;mygame.nmf&quot; type=&quot;application/x-pnacl&quot; /&gt;
</pre>
</li>
<li><p class="first"><strong>Manifest:</strong> The manifest identifies the module to load and specifies
options. For example, &#x201C;mygame.nmf&#x201D; might look like this:</p>
<pre class="prettyprint">{...
  ...
  &quot;url&quot;: &quot;mygame.pexe&quot;,
}
</pre>
</li>
<li><strong>pexe (portable NaCl file):</strong> A compiled Native Client module. It uses the
<a class="reference internal" href="#link-pepper"><em>Pepper API</em></a>, which provides a bridge to JavaScript and
other browser resources.</li>
</ul>
<div class="figure">
<img alt="Structure of a web application" src="/docs/native-client/images/nacl-in-a-web-app.png">
<p class="caption">Structure of a web application</p>
</div>
<p>For more details, see <a class="reference internal" href="/docs/native-client/devguide/coding/application-structure"><em>Application Structure</em></a>.</p>
<h3 id="pepper-plug-in-api"><span id="link-pepper"></span>Pepper plug-in API</h3>
<p>The Pepper plug-in API (PPAPI), called <strong>Pepper</strong> for convenience, is an
open-source, cross-platform C/C++ API for web browser plug-ins. Pepper allows a
C/C++ module to communicate with the hosting browser and to access system-level
functions in a safe and portable way. One of the security constraints in Native
Client is that modules cannot make OS-level calls. Pepper provides analogous
APIs that modules can use instead.</p>
<p>You can use the Pepper APIs to gain access to the full array of browser
capabilities, including:</p>
<ul>
<li><a class="reference internal" href="/docs/native-client/devguide/coding/message-system"><em>Talking to the JavaScript code in your application</em></a> from the C++ code in your NaCl module.</li>
<li><a class="reference internal" href="/docs/native-client/devguide/coding/file-io"><em>Doing file I/O</em></a>.</li>
<li><a class="reference internal" href="/docs/native-client/devguide/coding/audio"><em>Playing audio</em></a>.</li>
<li><a class="reference internal" href="/docs/native-client/devguide/coding/3D-graphics"><em>Rendering 3D graphics</em></a>.</li>
</ul>
<p>Pepper includes both a <a class="reference internal" href="/docs/native-client/c-api"><em>C API</em></a> and a <a class="reference internal" href="/docs/native-client/cpp-api"><em>C++ API</em></a>.
The C++ API is a set of bindings written on top of the C API. For additional
information about Pepper, see <a class="reference external" href="http://code.google.com/p/ppapi/wiki/Concepts">Pepper Concepts</a>.</p>
<h2 id="where-to-start">Where to start</h2>
<p>The <a class="reference internal" href="/docs/native-client/quick-start"><em>Quick Start</em></a> document provides links to downloads and
documentation to help you get started with developing and distributing Native
Client applications.</p>
</section>


</body></html>